{"version":3,"sources":["algorithms/dijkstra.js","algorithms/astar.js","PathfindingVisualizer/Node/Node.jsx","algorithms/bfs.js","algorithms/dfs.js","algorithms/greedybestfs.js","algorithms/BiDirectional.js","Maze/SimpleMaze.js","Maze/RecursiveDivision.js","PathfindingVisualizer/PathfindingVisualizer.jsx","Components/AlgorithmInfo.js","App.js","serviceWorker.js","index.js"],"names":["heap","yetToVisit","Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","Heap","a","b","distance","visitedNodesInOrder","node","push","getAllNodes","heapify","length","closestNode","pop","Infinity","visited","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","getAllFourNeighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","updateItem","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrderBiDirectional","array","element","arrayContainsGivenNode","Queue","queue","offset","getLength","isEmpty","enqueue","item","dequeue","slice","peek","undefined","astar","fCost","gCost","hCost","initializeCosts","currNode","unvisitedNeighbours","manhattanDistance","euclideanDistance","colA","colB","rowA","rowB","Math","abs","aSquared","pow","bSquared","INTERSECT_NODE_ROW","INTERSECT_NODE_COL","finished","DFS","DFSHelper","neighbour","greedyBestFS","size","isIntersecting","visitedByStart","visitedByFinish","getUnvisitedNeighborsStart","getUnvisitedNeighborsFinish","getRandomNumber","min","max","floor","random","nodesToBeWalls","typeOfMaze","recursiveDivision","rowStart","rowEnd","colStart","colEnd","orientation","type","recursiveDivisionMaze","possibleRows","number","possibleCols","randomRowIndex","randomColIndex","currentRow","colRandom","console","log","switchType","currentCol","rowRandom","maze1","maze2","maze3","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","mouseIsPressed","startIsPressed","finishIsPressed","isRunning","slideNumber","PathfindingVisualizer","state","createNode","getInitialGrid","setState","window","onload","openHelpMenu","document","getElementById","onmouseleave","i","setTimeout","animateShortestPath","algorithm","BFS","queueStart","queueFinish","currStartNode","currFinishNode","unvisitedNeighborsStart","unvisitedNeighborsFinish","biDirectional","biDirectionalHelper","animateAlgorithm","nodesInShortestPathOrder1","nodesInShortestPathOrder2","findSecondBranch","concat","firstBranch","rightBesideIntersectNode","rightWithinBounds","belowBesideIntersectNode","belowWithinBounds","leftBesideIntersectNode","leftWithinBounds","aboveBesideIntersectNode","aboveWithinBounds","nodesInShortestPathOrderTestRight","nodesInShortestPathOrderTestBelow","nodesInShortestPathOrderTestLeft","nodesInShortestPathOrderTestAbove","onClick","refreshPage","visualizeWalls","clearGrid","clearPath","changeText","openAlgorithmMenu","visualizeAlgorithm","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","maze","clearGridHelper","turnNodesToWalls","simpleMaze","NUM_ROWS","NUM_COLUMNS","animateWalls","newgrid","oldGrid","clearGridHelperKeepWalls","location","reload","modal","style","display","btn","span","getElementsByClassName","onclick","event","target","next","innerHTML","HTMLHelper","prevBtn","nextBtn","backgroundColor","disabled","MAXSLIDE","info","scrollTop","displayAlgorithmInfo","isVisited","App","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d9e5d83c.chunk.js","sourcesContent":["// https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Algorithm\n\nimport Heap from \"heap\";\n\nvar heap;\n\n// when beginning, assume all nodes in the grid to have a distance of infinity\nexport function dijkstra(grid, startNode, finishNode) {\n    // checks for invalid inputs\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n    }\n\n    // creates a priority queue of nodes where heap.pop()\n    // outputs the node with the smallest distance\n    heap = new Heap(function(a, b) {\n        return a.distance - b.distance;\n    });\n    const visitedNodesInOrder = [];\n\n    // initializes the starting node's distance to zero\n    startNode.distance = 0;\n\n    // adds all the nodes in the grid to the heap\n    getAllNodes(grid);\n\n    // creates a minimum heap\n    heap.heapify();\n\n    // Core\n    while (heap.length !== 0) {\n        //shift returns first element in array (with the smallest distance)\n        const closestNode = heap.pop();\n\n        // if closest node is a wall, skips the node\n        if (closestNode.isWall) continue;\n\n        // if closest node's distance is infinity, returns a list of the  visited nodes\n        // This means the shortest path to the finish node does not exist\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n        //marks the closest node as visited and appends it to those visited in order\n        closestNode.visited = true;\n        visitedNodesInOrder.push(closestNode);\n\n        // if we have arrived at the finish node, returns all the nodes visited\n        if (closestNode === finishNode) return visitedNodesInOrder;\n\n        // for all the unvisited neighbors, updates their distances respectively\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\n// Return all the nodes in the given grid and puts them into the heap\nfunction getAllNodes(grid) {\n    for (const row of grid) {\n        for (const node of row) {\n            heap.push(node);\n        }\n    }\n}\n\n// updates the distance for all the unvisited neighbors of node in grid\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.distance > node.distance + 1) {\n            neighbor.distance = node.distance + 1;\n            neighbor.previousNode = node;\n            heap.updateItem(neighbor);\n        }\n    }\n}\n\nexport function getAllFourNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors;\n}\n\n// return all the neighbors of node from grid\nexport function getUnvisitedNeighbors(node, grid) {\n    var neighbors = getAllFourNeighbors(node, grid);\n    // get rid of neighbors that were already visited\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n    //  if (!finishNode.visited || finishNode.isWall) return [];\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport function getNodesInShortestPathOrderBiDirectional(\n    node,\n    visitedNodesInOrder\n) {\n    //  if (!node.visited || node.isWall) return [];\n    if (!arrayContainsGivenNode(visitedNodesInOrder, node)) return [];\n    const nodesInShortestPathOrder = [];\n    let currentNode = node;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nfunction arrayContainsGivenNode(array, node) {\n    if (array === []) return false;\n    for (let element of array) {\n        if (element.row === node.row && element.col === node.col) {\n            return true;\n        }\n    }\n    return false;\n}\n","import { getUnvisitedNeighbors } from \"../algorithms/bfs\";\nimport Heap from \"heap\";\n\nvar yetToVisit;\n\nexport function astar(grid, startNode, finishNode) {\n    // checks for invalid inputs\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n    }\n    const visitedNodesInOrder = [];\n\n    // create a priority queue where heap.pop() is the node with the lowest fCost\n    yetToVisit = new Heap(function(a, b) {\n        return a.fCost - b.fCost;\n    });\n\n    // make all nodes have fCost, gCost, hCost infinity at first\n    initializeCosts(grid);\n\n    // set the costs of the startNode to 0\n    startNode.fCost = 0;\n    startNode.gCost = 0;\n    startNode.hCost = 0;\n\n    // create a priority queue using a min-heap\n    yetToVisit.heapify();\n\n    while (yetToVisit.length !== 0) {\n        const currNode = yetToVisit.pop();\n\n        // if node is undefined or current node has fCost of infinity, returns the list of visited nodes\n        if (typeof currNode === \"undefined\" || currNode.fCost === Infinity)\n            return visitedNodesInOrder;\n\n        // if the node is a wall, continues running\n        if (currNode.isWall) continue;\n\n        // marks the node as visited and add it to the list of visited nodes\n        currNode.visited = true;\n        visitedNodesInOrder.push(currNode);\n\n        // if the node equals the finish node, returns the list of visited nodes\n        if (currNode === finishNode) return visitedNodesInOrder;\n\n        // for all unvisited neighbors of the node, calculate the heuristic h(n),\n        // Manhattan distance is used for calculating h(n). Then checks the condition of g(n) and\n        // updates the costs of the node respectively.\n        const unvisitedNeighbours = getUnvisitedNeighbors(currNode, grid);\n        for (const neighbor of unvisitedNeighbours) {\n            if (!neighbor.isWall) {\n                let hCost = manhattanDistance(\n                    neighbor.col,\n                    finishNode.col,\n                    neighbor.row,\n                    finishNode.row\n                );\n\n                if (currNode.gCost + 1 < neighbor.gCost) {\n                    neighbor.hCost = hCost;\n                    neighbor.gCost = currNode.gCost + 1;\n                    neighbor.fCost = neighbor.hCost + neighbor.gCost;\n                    neighbor.previousNode = currNode;\n                    yetToVisit.updateItem(neighbor);\n                }\n            }\n        }\n    }\n    return visitedNodesInOrder;\n}\n\n// calculates the Euclidean distance\nexport function euclideanDistance(colA, colB, rowA, rowB) {\n    const a = Math.abs(colA - colB);\n    const b = Math.abs(rowA - rowB);\n    const aSquared = Math.pow(a, 2);\n    const bSquared = Math.pow(b, 2);\n    return Math.pow(aSquared + bSquared, 0.5);\n}\n\n// calculates the Manhanttan distance\nexport function manhattanDistance(colA, colB, rowA, rowB) {\n    const a = Math.abs(colA - colB);\n    const b = Math.abs(rowA - rowB);\n    return a + b;\n}\n\n// Make all nodes' fCost, gCost and hCost values initialized to infinity\n// and stores it in the heap.\nfunction initializeCosts(grid) {\n    for (let row of grid) {\n        for (let node of row) {\n            node.fCost = Infinity;\n            node.gCost = Infinity;\n            node.hCost = Infinity;\n            yetToVisit.push(node);\n        }\n    }\n}\n","import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n    render() {\n        const {\n            col,\n            isFinish,\n            isStart,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp,\n            row\n        } = this.props;\n        const extraClassName = isFinish\n            ? \"node-finish\"\n            : isStart\n            ? \"node-start\"\n            : isWall\n            ? \"node-wall\"\n            : \"\";\n\n        return (\n            <div\n                id={`node-${row}-${col}`}\n                className={`node ${extraClassName}`}\n                onMouseDown={() => onMouseDown(row, col)}\n                onMouseEnter={() => onMouseEnter(row, col)}\n                onMouseUp={() => onMouseUp()}\n            ></div>\n        );\n    }\n}\n\n// export const DEFAULT_NODE = {\n//     row: 0,\n//     col: 0\n// };\n","export function BFS(grid, startNode, finishNode) {\n    //checks for invalid inputs\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n    }\n    const visitedNodesInOrder = [];\n    //creates a new queue\n    var queue = new Queue();\n\n    //initialize the start node distance to 0 and add it to the queue\n    startNode.distance = 0;\n    queue.enqueue(startNode);\n\n    while (queue.length !== 0) {\n        var currentNode = queue.dequeue();\n\n        // checks for any invalid nodes\n        if (typeof currentNode === \"undefined\") return visitedNodesInOrder;\n\n        //if the node is a wall, repeat the loop again\n        if (currentNode.isWall) continue;\n\n        // marks the node as visited and adds it to the list of visited nodes\n        currentNode.distance = 0;\n        currentNode.visited = true;\n        visitedNodesInOrder.push(currentNode);\n\n        // if the current node arrives at the goal, returns the list of the visited nodes\n        if (currentNode === finishNode) return visitedNodesInOrder;\n\n        // fetches the unvisited neighbors of the current node and adds them to the queue\n        const unvisitedNeighbours = getUnvisitedNeighbors(currentNode, grid);\n        for (const neighbor of unvisitedNeighbours) {\n            if (!neighbor.isWall) {\n                queue.enqueue(neighbor);\n                neighbor.visited = true;\n                neighbor.previousNode = currentNode;\n                neighbor.distance = 0;\n            }\n        }\n    }\n}\n\n// fetches the neighbors(up, down, left and right) of the current node\nexport function getAllFourNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors;\n}\n\n// returns all the neighbors of the node from the grid\nexport function getUnvisitedNeighbors(node, grid) {\n    var neighbors = getAllFourNeighbors(node, grid);\n    // get rid of neighbors that were already visited\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\n/*\nQueue.js\nA function to represent a queue\nCreated by Kate Morley - http://code.iamkate.com/ - and released under the terms\nof the CC0 1.0 Universal legal code:\nhttp://creativecommons.org/publicdomain/zero/1.0/legalcode\n*/\n\nfunction Queue() {\n    // initialise the queue and offset\n    var queue = [];\n    var offset = 0;\n\n    // Returns the length of the queue.\n    this.getLength = function() {\n        return queue.length - offset;\n    };\n\n    // Returns true if the queue is empty, and false otherwise.\n    this.isEmpty = function() {\n        return queue.length === 0;\n    };\n\n    /* Enqueues the specified item. The parameter is:\n     *\n     * item - the item to enqueue\n     */\n    this.enqueue = function(item) {\n        queue.push(item);\n    };\n\n    /* Dequeues an item and returns it. If the queue is empty, the value\n     * 'undefined' is returned.\n     */\n    this.dequeue = function() {\n        // if the queue is empty, return immediately\n        if (queue.length === 0) return undefined;\n\n        // store the item at the front of the queue\n        var item = queue[offset];\n\n        // increment the offset and remove the free space if necessary\n        if (++offset * 2 >= queue.length) {\n            queue = queue.slice(offset);\n            offset = 0;\n        }\n\n        // return the dequeued item\n        return item;\n    };\n\n    /* Returns the item at the front of the queue (without dequeuing it). If the\n     * queue is empty then undefined is returned.\n     */\n    this.peek = function() {\n        return queue.length > 0 ? queue[offset] : undefined;\n    };\n}\n","import { getUnvisitedNeighbors } from \"../algorithms/bfs\";\n\nvar visitedNodesInOrder = [];\nvar finished = 0;\n\nexport function DFS(grid, startNode, finishNode) {\n    visitedNodesInOrder = [];\n    return DFSHelper(grid, startNode, finishNode);\n}\n\n// loops around the node and dives deeper into its neighbors in search of the finish node.\nfunction DFSHelper(grid, startNode, finishNode) {\n    // checks for invalid inputs\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n    }\n\n    // returns if start node is a wall or has been visited\n    if (startNode.isWall || startNode.visited) return;\n    startNode.visited = true;\n\n    // pushes the start node into the visited nodes list\n    visitedNodesInOrder.push(startNode);\n\n    // when the finish node has been found, returns the list of visited nodes\n    if (startNode === finishNode) {\n        finished = 1;\n        return visitedNodesInOrder;\n    }\n\n    // fetches the unvisited neighbors\n    var unvisitedNeighbours = getUnvisitedNeighbors(startNode, grid);\n\n    // loops into itself for each neighbor of the unvisited neighbors until finish node has been discovered\n    for (var neighbour of unvisitedNeighbours) {\n        if (!neighbour.isWall && !neighbour.visited) {\n            neighbour.previousNode = startNode;\n            if (finished === 1) {\n                return visitedNodesInOrder;\n            }\n            DFSHelper(grid, neighbour, finishNode);\n            if (finished === 1) {\n                return visitedNodesInOrder;\n            }\n        }\n    }\n\n    return visitedNodesInOrder;\n}\n","import { getUnvisitedNeighbors } from \"../algorithms/bfs\";\nimport Heap from \"heap\";\nimport { euclideanDistance } from \"../algorithms/astar\";\n\nvar yetToVisit;\n\nexport function greedyBestFS(grid, startNode, finishNode) {\n    // checks for invalid inputs\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n    }\n\n    const visitedNodesInOrder = [];\n\n    // creates a priority queue such that yetToVisit.pop() returns the node with the\n    // lowest fCost value\n    yetToVisit = new Heap(function(a, b) {\n        return a.fCost - b.fCost;\n    });\n\n    // sets the hCost and fCost of every node in the grid to infinity\n    initializeCosts(grid);\n\n    // initializes start node's fCost to zero and adds it to the priority queue\n    startNode.fCost = 0;\n    yetToVisit.updateItem(startNode);\n    yetToVisit.heapify();\n\n    // Core loop\n    while (yetToVisit.size() > 0) {\n        // returns the node with the lowest fCost as the current node\n        const currentNode = yetToVisit.pop();\n\n        // if the current node is invalid, returns the visited nodes\n        if (typeof currentNode === \"undefined\") return visitedNodesInOrder;\n\n        // if the current node's fCost is infinity, returns the visited nodes\n        if (currentNode.fCost === Infinity) return visitedNodesInOrder;\n\n        // if the current node is a wall, skips the node\n        if (currentNode.isWall) continue;\n\n        // marks the current node as visited and pushes it to the list of visited nodes\n        currentNode.visited = true;\n        visitedNodesInOrder.push(currentNode);\n\n        // if current node has found the finish node, returns the visited nodes\n        if (currentNode === finishNode) return visitedNodesInOrder;\n\n        // for all unvisited neighbors of the node, calculate the heuristics h(n)\n        // Utilises Euclidean distance, then checks f(n) and updates the costs of the nodes respectively\n        const unvisitedNeighbours = getUnvisitedNeighbors(currentNode, grid);\n        for (const neighbor of unvisitedNeighbours) {\n            if (!neighbor.isWall) {\n                const hCost = euclideanDistance(\n                    neighbor.col,\n                    finishNode.col,\n                    neighbor.row,\n                    finishNode.row\n                );\n\n                if (neighbor.fCost > hCost) {\n                    neighbor.fCost = hCost; //no g cost\n                    neighbor.previousNode = currentNode;\n                    yetToVisit.updateItem(neighbor);\n                }\n            }\n        }\n    }\n\n    return visitedNodesInOrder;\n}\n\n// initializes the fcosts and hcosts of the nodes to infinity\nfunction initializeCosts(grid) {\n    for (let row of grid) {\n        for (let node of row) {\n            node.fCost = Infinity;\n            node.hCost = Infinity;\n            yetToVisit.push(node);\n        }\n    }\n}\n","import { getAllFourNeighbors } from \"../algorithms/bfs\";\n\nexport var INTERSECT_NODE_ROW;\nexport var INTERSECT_NODE_COL;\n\nexport function biDirectional(grid, startNode, finishNode) {\n    INTERSECT_NODE_ROW = -1;\n    INTERSECT_NODE_COL = -1;\n    // checks for invalid inputs\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n    }\n\n    const visitedNodesInOrder = [];\n\n    // initializes two queues, one queue for the start node and one for the finish node\n    // adds the start and finish nodes into the queue respectively\n    var queueStart = new Queue();\n    var queueFinish = new Queue();\n    queueStart.enqueue(startNode);\n    queueFinish.enqueue(finishNode);\n\n    // Core\n    while (queueStart.length !== 0 && queueFinish.length !== 0) {\n        var currStartNode = queueStart.dequeue();\n        var currFinishNode = queueFinish.dequeue();\n\n        // checks for if start node or finish node is invalid\n        if (typeof currStartNode === \"undefined\") {\n            return visitedNodesInOrder;\n        }\n        if (typeof currFinishNode === \"undefined\") {\n            return visitedNodesInOrder;\n        }\n\n        // marks the removed from nodes as visited and adds them to the visited nodes list\n        currStartNode.visited = true;\n        currFinishNode.visited = true;\n        visitedNodesInOrder.push(currStartNode);\n        visitedNodesInOrder.push(currFinishNode);\n\n        // if start and finish node intersects each other, returns the visited nodes\n        if (isIntersecting(visitedNodesInOrder)) {\n            return visitedNodesInOrder;\n        }\n\n        // fetches the neighboring nodes for the start and finish node\n        const unvisitedNeighborsStart = getUnvisitedNeighborsStart(\n            currStartNode,\n            grid\n        );\n        const unvisitedNeighborsFinish = getUnvisitedNeighborsFinish(\n            currFinishNode,\n            grid\n        );\n\n        // for every unvisited neighbor of the two nodes\n        // push them into their respective queues\n        for (const neighbor of unvisitedNeighborsStart) {\n            if (!neighbor.isWall) {\n                neighbor.visited = true;\n                neighbor.visitedByStart = true;\n                neighbor.previousNode = currStartNode;\n                queueStart.enqueue(neighbor);\n            }\n        }\n\n        for (const neighbor of unvisitedNeighborsFinish) {\n            if (!neighbor.isWall) {\n                neighbor.visited = true;\n                neighbor.visitedByFinish = true;\n                neighbor.previousNode = currFinishNode;\n                queueFinish.enqueue(neighbor);\n            }\n        }\n    }\n}\n\n// checks to see if the nodes are intersecting\nfunction isIntersecting(visitedNodesInOrder) {\n    for (var node of visitedNodesInOrder) {\n        if (node.visitedByStart && node.visitedByFinish && !node.isWall) {\n            INTERSECT_NODE_ROW = node.row;\n            INTERSECT_NODE_COL = node.col;\n            return true;\n        }\n    }\n    return false;\n}\n\n// returns all the neighbors of the start node from the grid\nfunction getUnvisitedNeighborsStart(node, grid) {\n    var neighbors = getAllFourNeighbors(node, grid);\n    // keep neighbors that are unvisited OR visited by finishNode\n    return neighbors.filter(\n        neighbor => neighbor.visitedByFinish || !neighbor.visited\n    );\n}\n\n// returns all the neighbors of the finish node from the grid\nfunction getUnvisitedNeighborsFinish(node, grid) {\n    var neighbors = getAllFourNeighbors(node, grid);\n    // keep neighbors that are unvisited OR visited by startNode\n    return neighbors.filter(\n        neighbor => neighbor.visitedByStart || !neighbor.visited\n    );\n}\n\n/*\n\nQueue.js\n\nA function to represent a queue\n\nCreated by Kate Morley - http://code.iamkate.com/ - and released under the terms\nof the CC0 1.0 Universal legal code:\n\nhttp://creativecommons.org/publicdomain/zero/1.0/legalcode\n\n*/\n\nfunction Queue() {\n    // initialise the queue and offset\n    var queue = [];\n    var offset = 0;\n\n    // Returns the length of the queue.\n    this.getLength = function() {\n        return queue.length - offset;\n    };\n\n    // Returns true if the queue is empty, and false otherwise.\n    this.isEmpty = function() {\n        return queue.length === 0;\n    };\n\n    /* Enqueues the specified item. The parameter is:\n     *\n     * item - the item to enqueue\n     */\n    this.enqueue = function(item) {\n        queue.push(item);\n    };\n\n    /* Dequeues an item and returns it. If the queue is empty, the value\n     * 'undefined' is returned.\n     */\n    this.dequeue = function() {\n        // if the queue is empty, return immediately\n        if (queue.length === 0) return undefined;\n\n        // store the item at the front of the queue\n        var item = queue[offset];\n\n        // increment the offset and remove the free space if necessary\n        if (++offset * 2 >= queue.length) {\n            queue = queue.slice(offset);\n            offset = 0;\n        }\n\n        // return the dequeued item\n        return item;\n    };\n\n    /* Returns the item at the front of the queue (without dequeuing it). If the\n     * queue is empty then undefined is returned.\n     */\n    this.peek = function() {\n        return queue.length > 0 ? queue[offset] : undefined;\n    };\n}\n","export function simpleMaze(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n        return false;\n    }\n\n    const turnNodesToWalls = [];\n\n    // Randomly turns nodes into walls based on the range provided for\n    // getRandomNumber function.\n    for (const row of grid) {\n        for (const node of row) {\n            if (getRandomNumber(0, 100) < 50 && getRandomNumber(0, 4) < 2) {\n                if (!node.isStart && !node.isFinish) {\n                    turnNodesToWalls.push(node);\n                    node.isWall = true;\n                }\n            }\n        }\n    }\n    return turnNodesToWalls;\n}\n\n// Generates a random number between a minimum value and maximum value.\nfunction getRandomNumber(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","var nodesToBeWalls = [];\nvar typeOfMaze = \"\";\n\nexport function recursiveDivision(\n    grid,\n    rowStart,\n    rowEnd,\n    colStart,\n    colEnd,\n    orientation,\n    type\n) {\n    nodesToBeWalls = [];\n    typeOfMaze = type;\n\n    recursiveDivisionMaze(\n        grid,\n        rowStart,\n        rowEnd,\n        colStart,\n        colEnd,\n        orientation\n    );\n    return nodesToBeWalls;\n}\n\nexport function recursiveDivisionMaze(\n    grid,\n    rowStart,\n    rowEnd,\n    colStart,\n    colEnd,\n    orientation\n) {\n    if (rowEnd < rowStart || colEnd < colStart) return;\n\n    if (orientation === \"HORIZONTAL\") {\n        let possibleRows = [];\n        for (let number = rowStart; number <= rowEnd; number += 2) {\n            possibleRows.push(number);\n        }\n\n        let possibleCols = [];\n        for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n            possibleCols.push(number);\n        }\n\n        let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n        let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n        let currentRow = possibleRows[randomRowIndex];\n        let colRandom = possibleCols[randomColIndex];\n\n        const row = grid[currentRow];\n        for (const node of row) {\n            if (\n                node.row === currentRow &&\n                !node.isStart &&\n                !node.isFinish &&\n                node.col !== colRandom &&\n                !node.visited &&\n                node.col >= colStart - 1 &&\n                node.col <= colEnd + 1\n            ) {\n                console.log(node);\n                node.isWall = true;\n                node.visited = true;\n                nodesToBeWalls.push(node);\n            }\n        }\n\n        if (currentRow - 2 - rowStart > colEnd - colStart) {\n            recursiveDivisionMaze(\n                grid,\n                rowStart,\n                currentRow - 2,\n                colStart,\n                colEnd,\n                switchType(orientation, orientation, \"VERTICAL\")\n            );\n        } else {\n            recursiveDivisionMaze(\n                grid,\n                rowStart,\n                currentRow - 2,\n                colStart,\n                colEnd,\n                switchType(\"VERTICAL\", \"VERTICAL\", \"VERTICAL\")\n            );\n        }\n        if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n            recursiveDivisionMaze(\n                grid,\n                currentRow + 2,\n                rowEnd,\n                colStart,\n                colEnd,\n                switchType(orientation, orientation, \"VERTICAL\")\n            );\n        } else {\n            recursiveDivisionMaze(\n                grid,\n                currentRow + 2,\n                rowEnd,\n                colStart,\n                colEnd,\n                switchType(\"VERTICAL\", \"VERTICAL\", \"VERTICAL\")\n            );\n        }\n    } else {\n        let possibleCols = [];\n        for (let number = colStart; number <= colEnd; number += 2) {\n            possibleCols.push(number);\n        }\n        let possibleRows = [];\n        for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n            possibleRows.push(number);\n        }\n        let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n        let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n        let currentCol = possibleCols[randomColIndex];\n        let rowRandom = possibleRows[randomRowIndex];\n\n        for (let row = rowStart - 1; row <= rowEnd + 1; row++) {\n            const nodes = grid[row];\n            const node = nodes[currentCol];\n            if (\n                !node.isStart &&\n                !node.isFinish &&\n                node.col === currentCol &&\n                !node.visited &&\n                node.row >= rowStart - 1 &&\n                node.row <= rowEnd + 1 &&\n                node.row !== rowRandom\n            ) {\n                node.visited = true;\n                node.isWall = true;\n                nodesToBeWalls.push(node);\n            }\n        }\n\n        if (rowEnd - rowStart > currentCol - 2 - colStart) {\n            recursiveDivisionMaze(\n                grid,\n                rowStart,\n                rowEnd,\n                colStart,\n                currentCol - 2,\n                switchType(\"HORIZONTAL\", \"HORIZONTAL\", orientation)\n            );\n        } else {\n            recursiveDivisionMaze(\n                grid,\n                rowStart,\n                rowEnd,\n                colStart,\n                currentCol - 2,\n                switchType(orientation, \"HORIZONTAL\", orientation)\n            );\n        }\n        if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n            recursiveDivisionMaze(\n                grid,\n                rowStart,\n                rowEnd,\n                currentCol + 2,\n                colEnd,\n                switchType(\"HORIZONTAL\", \"HORIZONTAL\", \"HORIZONTAL\")\n            );\n        } else {\n            recursiveDivisionMaze(\n                grid,\n                rowStart,\n                rowEnd,\n                currentCol + 2,\n                colEnd,\n                switchType(orientation, \"HORIZONTAL\", orientation)\n            );\n        }\n    }\n}\n\nfunction switchType(maze1, maze2, maze3) {\n    if (typeOfMaze === \"regularMaze\") {\n        return maze1;\n    } else if (typeOfMaze === \"horizontalMaze\") {\n        return maze2;\n    } else if (typeOfMaze === \"verticalMaze\") {\n        return maze3;\n    }\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\n\nimport {\n    dijkstra,\n    getNodesInShortestPathOrder,\n    getNodesInShortestPathOrderBiDirectional\n} from \"../algorithms/dijkstra\";\nimport { astar } from \"../algorithms/astar\";\nimport { BFS } from \"../algorithms/bfs\";\nimport { DFS } from \"../algorithms/dfs\";\nimport { greedyBestFS } from \"../algorithms/greedybestfs\";\nimport {\n    biDirectional,\n    INTERSECT_NODE_COL,\n    INTERSECT_NODE_ROW\n} from \"../algorithms/BiDirectional\";\nimport { simpleMaze } from \"../Maze/SimpleMaze\";\nimport { recursiveDivision } from \"../Maze/RecursiveDivision\";\nimport { displayAlgorithmInfo } from \"../Components/AlgorithmInfo\";\n\nimport \"./PathfindingVisualizer.css\";\nimport \"../Components/Button.css\";\nimport \"../Components/Modal.css\";\nimport \"../Components/AlgorithmModal.css\";\n\nexport const NUM_COLUMNS = 50;\nexport const NUM_ROWS = 20;\nvar START_NODE_ROW = 10;\nvar START_NODE_COL = 15;\nvar FINISH_NODE_ROW = 10;\nvar FINISH_NODE_COL = 35;\nvar mouseIsPressed = false;\nvar startIsPressed = false;\nvar finishIsPressed = false;\nvar isRunning = false;\nvar slideNumber = 0;\n\nexport default class PathfindingVisualizer extends Component {\n    constructor() {\n        super();\n        this.state = {\n            grid: []\n        };\n    }\n\n    componentDidMount() {\n        const grid = getInitialGrid();\n        this.setState({ grid });\n        // renders the Help Menu once page first loads\n        window.onload = this.openHelpMenu();\n    }\n\n    handleMouseDown(row, col) {\n        if (isRunning) return;\n\n        const grid = this.state.grid;\n        mouseIsPressed = true;\n\n        var node = grid[row][col];\n\n        // allows the starting node to be positioned at any node on the grid\n        if (node.isStart) {\n            startIsPressed = true;\n            return;\n        }\n\n        // allows the finish node to be positioned similar to the starting node\n        if (node.isFinish) {\n            finishIsPressed = true;\n            return;\n        }\n        node.isWall = !node.isWall;\n        if (node.isWall && !node.isStart && !node.isFinish) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n                \"node node-wall\";\n        } else if (!node.isStart && !node.isFinish) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n                \"node\";\n        }\n    }\n\n    handleMouseEnter(row, col) {\n        if (!mouseIsPressed || isRunning) return;\n        var div = document.getElementById(\"grid\");\n        div.onmouseleave = function() {\n            console.log(\"mouse exited\");\n            startIsPressed = false;\n            finishIsPressed = false;\n            mouseIsPressed = false;\n        };\n\n        const grid = this.state.grid;\n\n        var node = grid[row][col];\n\n        if (startIsPressed) {\n            if (node.isFinish || node.isWall) return;\n\n            var startNode = grid[START_NODE_ROW][START_NODE_COL];\n            document.getElementById(\n                `node-${START_NODE_ROW}-${START_NODE_COL}`\n            ).className = \"node\";\n            startNode.isStart = false;\n            startNode.isWall = false;\n            node.isStart = true;\n            node.isWall = false;\n            START_NODE_ROW = row;\n            START_NODE_COL = col;\n            document.getElementById(`node-${row}-${col}`).className =\n                \"node node-start\";\n            return;\n        } else if (finishIsPressed) {\n            if (node.isStart || node.isWall) return;\n\n            var finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n            document.getElementById(\n                `node-${finishNode.row}-${finishNode.col}`\n            ).className = \"node\";\n            finishNode.isFinish = false;\n            finishNode.isWall = false;\n            node.isFinish = true;\n            node.isWall = false;\n            FINISH_NODE_ROW = row;\n            FINISH_NODE_COL = col;\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n                \"node node-finish\";\n            return;\n        }\n\n        if (node.isStart || node.isFinish) return;\n\n        node.isWall = !node.isWall;\n        if (node.isWall && !node.isStart && !node.isFinish) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n                \"node node-wall\";\n        } else if (!node.isStart && !node.isFinish) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n                \"node\";\n        }\n    }\n\n    handleMouseUp() {\n        if (isRunning) return;\n        startIsPressed = false;\n        finishIsPressed = false;\n        mouseIsPressed = false;\n    }\n\n    // setTimeout executes the function after a certain number of milliseconds have past\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n            if (i === visitedNodesInOrder.length) {\n                setTimeout(() => {\n                    this.animateShortestPath(nodesInShortestPathOrder);\n                }, 10 * i);\n                return;\n            }\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className = \"node node-visited\";\n            }, 10 * i);\n        }\n    }\n\n    animateShortestPath(nodesInShortestPathOrder) {\n        if (\n            nodesInShortestPathOrder == null ||\n            nodesInShortestPathOrder.length <= 1\n        ) {\n            document.getElementById(\n                `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\n            ).className = \"node node-visited-invalid-finish\";\n            isRunning = false;\n            return;\n        }\n\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n            setTimeout(() => {\n                const node = nodesInShortestPathOrder[i];\n                if (typeof node === \"undefined\") {\n                    isRunning = false;\n                    return;\n                }\n                if (node.isFinish) {\n                    document.getElementById(\n                        `node-${node.row}-${node.col}`\n                    ).className = \"node node-visited-finish\";\n                } else if (node.isStart) {\n                    document.getElementById(\n                        `node-${START_NODE_ROW}-${START_NODE_COL}`\n                    ).className = \"node node-visited-start\";\n                } else {\n                    document.getElementById(\n                        `node-${node.row}-${node.col}`\n                    ).className = \"node node-shortest-path\";\n                }\n                if (i === nodesInShortestPathOrder.length - 1) {\n                    isRunning = false;\n                }\n            }, 50 * i);\n        }\n    }\n\n    visualizeAlgorithm(algorithm) {\n        const { grid } = this.state;\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n        var nodesInShortestPathOrder;\n\n        var visitedNodesInOrder = null;\n        switch (algorithm) {\n            case 0: {\n                visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n                break;\n            }\n            case 1: {\n                visitedNodesInOrder = BFS(grid, startNode, finishNode);\n                break;\n            }\n            case 2: {\n                visitedNodesInOrder = DFS(grid, startNode, finishNode);\n                break;\n            }\n            case 3: {\n                visitedNodesInOrder = astar(grid, startNode, finishNode);\n                break;\n            }\n            case 4: {\n                visitedNodesInOrder = greedyBestFS(grid, startNode, finishNode);\n                break;\n            }\n            case 5: {\n                visitedNodesInOrder = biDirectional(\n                    grid,\n                    startNode,\n                    finishNode\n                );\n                nodesInShortestPathOrder = this.biDirectionalHelper(\n                    grid,\n                    visitedNodesInOrder\n                );\n                break;\n            }\n            default:\n                visitedNodesInOrder = astar(grid, startNode, finishNode);\n                break;\n        }\n\n        if (algorithm !== 5) {\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        }\n\n        if (visitedNodesInOrder !== false) {\n            console.log(grid);\n            if (algorithm === 5) {\n                this.animateAlgorithm(\n                    visitedNodesInOrder,\n                    nodesInShortestPathOrder\n                );\n            } else {\n                this.animateAlgorithm(\n                    visitedNodesInOrder,\n                    nodesInShortestPathOrder\n                );\n            }\n        }\n    }\n\n    biDirectionalHelper(grid, visitedNodesInOrder) {\n        var nodesInShortestPathOrder = [];\n        if (\n            typeof INTERSECT_NODE_COL !== \"undefined\" &&\n            typeof INTERSECT_NODE_ROW !== \"undefined\" &&\n            INTERSECT_NODE_ROW !== -1 &&\n            INTERSECT_NODE_COL !== -1\n        ) {\n            const intersectNode = grid[INTERSECT_NODE_ROW][INTERSECT_NODE_COL];\n            //get first branch from intersection Node\n            const nodesInShortestPathOrder1 = getNodesInShortestPathOrder(\n                intersectNode\n            );\n            //find second branch from one of 4 nodes beside intersection node\n            const nodesInShortestPathOrder2 = this.findSecondBranch(\n                grid,\n                nodesInShortestPathOrder1,\n                visitedNodesInOrder\n            );\n            //combine first and second branch to form shortest path\n            const nodesInShortestPathOrderCombined = nodesInShortestPathOrder1.concat(\n                nodesInShortestPathOrder2\n            );\n            //console.log(nodesInShortestPathOrder);\n            nodesInShortestPathOrder = nodesInShortestPathOrderCombined;\n        }\n        return nodesInShortestPathOrder;\n    }\n\n    findSecondBranch(grid, firstBranch, visitedNodesInOrder) {\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n        let rightBesideIntersectNode = null;\n        let rightWithinBounds = true;\n        if (INTERSECT_NODE_COL + 1 >= NUM_COLUMNS) rightWithinBounds = false;\n        else\n            rightBesideIntersectNode =\n                grid[INTERSECT_NODE_ROW][INTERSECT_NODE_COL + 1];\n\n        let belowBesideIntersectNode = null;\n        let belowWithinBounds = true;\n        if (INTERSECT_NODE_ROW + 1 >= NUM_ROWS) belowWithinBounds = false;\n        else\n            belowBesideIntersectNode =\n                grid[INTERSECT_NODE_ROW + 1][INTERSECT_NODE_COL];\n\n        let leftBesideIntersectNode = null;\n        let leftWithinBounds = true;\n        if (INTERSECT_NODE_COL - 1 < 0) leftWithinBounds = false;\n        else\n            leftBesideIntersectNode =\n                grid[INTERSECT_NODE_ROW][INTERSECT_NODE_COL - 1];\n\n        let aboveBesideIntersectNode = null;\n        let aboveWithinBounds = true;\n        if (INTERSECT_NODE_ROW - 1 < 0) aboveWithinBounds = false;\n        else\n            aboveBesideIntersectNode =\n                grid[INTERSECT_NODE_ROW - 1][INTERSECT_NODE_COL];\n\n        let nodesInShortestPathOrderTestRight = [];\n\n        if (rightWithinBounds) {\n            nodesInShortestPathOrderTestRight = getNodesInShortestPathOrderBiDirectional(\n                rightBesideIntersectNode,\n                visitedNodesInOrder\n            );\n        }\n        let nodesInShortestPathOrderTestBelow = [];\n        if (belowWithinBounds) {\n            nodesInShortestPathOrderTestBelow = getNodesInShortestPathOrderBiDirectional(\n                belowBesideIntersectNode,\n                visitedNodesInOrder\n            );\n        }\n        let nodesInShortestPathOrderTestLeft = [];\n        if (leftWithinBounds) {\n            nodesInShortestPathOrderTestLeft = getNodesInShortestPathOrderBiDirectional(\n                leftBesideIntersectNode,\n                visitedNodesInOrder\n            );\n        }\n        let nodesInShortestPathOrderTestAbove = [];\n        if (aboveWithinBounds) {\n            nodesInShortestPathOrderTestAbove = getNodesInShortestPathOrderBiDirectional(\n                aboveBesideIntersectNode,\n                visitedNodesInOrder\n            );\n        }\n\n        if (this.arrayContainsGivenNode(firstBranch, startNode)) {\n            //first branch leads to startNode\n            //we check all test branches, to see if they lead to finish Node. if they do, return it\n            if (\n                rightWithinBounds &&\n                this.arrayContainsGivenNode(\n                    nodesInShortestPathOrderTestRight,\n                    finishNode\n                )\n            )\n                return nodesInShortestPathOrderTestRight;\n\n            if (\n                belowWithinBounds &&\n                this.arrayContainsGivenNode(\n                    nodesInShortestPathOrderTestBelow,\n                    finishNode\n                )\n            )\n                return nodesInShortestPathOrderTestBelow;\n\n            if (\n                leftWithinBounds &&\n                this.arrayContainsGivenNode(\n                    nodesInShortestPathOrderTestLeft,\n                    finishNode\n                )\n            )\n                return nodesInShortestPathOrderTestLeft;\n\n            if (\n                aboveWithinBounds &&\n                this.arrayContainsGivenNode(\n                    nodesInShortestPathOrderTestAbove,\n                    finishNode\n                )\n            )\n                return nodesInShortestPathOrderTestAbove;\n        } else {\n            //first branch leads to finishNode\n            // we check all test branches, to see if they lead to start node. if they do, return it\n            if (\n                this.arrayContainsGivenNode(\n                    rightWithinBounds && nodesInShortestPathOrderTestRight,\n                    startNode\n                )\n            )\n                return nodesInShortestPathOrderTestRight;\n\n            if (\n                this.arrayContainsGivenNode(\n                    belowWithinBounds && nodesInShortestPathOrderTestBelow,\n                    startNode\n                )\n            )\n                return nodesInShortestPathOrderTestBelow;\n\n            if (\n                leftWithinBounds &&\n                this.arrayContainsGivenNode(\n                    nodesInShortestPathOrderTestLeft,\n                    startNode\n                )\n            )\n                return nodesInShortestPathOrderTestLeft;\n\n            if (\n                aboveWithinBounds &&\n                this.arrayContainsGivenNode(\n                    nodesInShortestPathOrderTestAbove,\n                    startNode\n                )\n            )\n                return nodesInShortestPathOrderTestAbove;\n        }\n    }\n\n    arrayContainsGivenNode(array, node) {\n        if (array === []) return false;\n        for (let element of array) {\n            if (element.row === node.row && element.col === node.col) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    render() {\n        const { grid, mouseIsPressed } = this.state;\n\n        return (\n            <>\n                <div className=\"title-container\">\n                    <div className=\"title\" onClick={() => this.refreshPage()}>\n                        Pathfinding Visualizer\n                    </div>\n\n                    <div className=\"title-button-row\">\n                        <button onClick={() => this.visualizeWalls(1)}>\n                            {\" \"}\n                            Recursive Division{\" \"}\n                        </button>\n                        <button onClick={() => this.visualizeWalls(0)}>\n                            {\" \"}\n                            Random Maze{\" \"}\n                        </button>\n                        <button onClick={() => this.visualizeWalls(2)}>\n                            {\" \"}\n                            Vertical Maze{\" \"}\n                        </button>\n                        <button onClick={() => this.visualizeWalls(3)}>\n                            {\" \"}\n                            Horizontal Maze{\" \"}\n                        </button>\n                        <button onClick={() => this.clearGrid()}>\n                            Clear Board\n                        </button>\n                        <button onClick={() => this.clearPath(grid)}>\n                            Clear Path\n                        </button>\n                    </div>\n                    <button\n                        id=\"info-button\"\n                        className=\"info-button\"\n                        onClick={() => this.openHelpMenu()}\n                    >\n                        {\" \"}\n                        ?{\" \"}\n                    </button>\n                </div>\n\n                <div id=\"helpMenu\" className=\"modal\">\n                    <div className=\"modal-container\">\n                        <span id=\"close\" className=\"close\">\n                            &times;\n                        </span>\n                        <div className=\"buttons-container\">\n                            <div className=\"info-buttons\">\n                                <button\n                                    id=\"Prev\"\n                                    onClick={() => this.changeText(-1)}\n                                >\n                                    {\" \"}\n                                    Prev{\" \"}\n                                </button>\n                                <button\n                                    id=\"Next\"\n                                    onClick={() => this.changeText(1)}\n                                >\n                                    {\" \"}\n                                    Next{\" \"}\n                                </button>\n                            </div>\n                        </div>\n                    </div>\n                    <div id=\"helpMenu-content\" className=\"modal-content\"></div>\n                </div>\n\n                <div id=\"algo-modal\" className=\"algo-modal\">\n                    <span id=\"algo-close\" className=\"algo-close\">\n                        &times;\n                    </span>\n                    <div\n                        id=\"algo-modal-content\"\n                        className=\"algo-modal-content\"\n                    ></div>\n                </div>\n\n                <div className=\"container\">\n                    <div className=\"algo-btn-group\">\n                        <button onClick={() => this.openAlgorithmMenu(0)}>\n                            {\"   \"}\n                            &#9432;{\"   \"}\n                        </button>\n                        <button onClick={() => this.openAlgorithmMenu(1)}>\n                            {\"   \"}\n                            &#9432;{\"   \"}\n                        </button>\n                        <button onClick={() => this.openAlgorithmMenu(2)}>\n                            {\"   \"}\n                            &#9432;{\"   \"}\n                        </button>\n                        <button onClick={() => this.openAlgorithmMenu(3)}>\n                            {\"   \"}\n                            &#9432;{\"   \"}\n                        </button>\n                        <button onClick={() => this.openAlgorithmMenu(4)}>\n                            {\"   \"}\n                            &#9432;{\"   \"}\n                        </button>\n                        <button onClick={() => this.openAlgorithmMenu(5)}>\n                            {\" \"}\n                            &#9432;{\" \"}\n                        </button>\n                    </div>\n                    <div className=\"btn-group\">\n                        <button onClick={() => this.visualizeAlgorithm(0)}>\n                            Dijkstra's Algorithm\n                        </button>\n                        <button onClick={() => this.visualizeAlgorithm(1)}>\n                            Breadth First Search\n                        </button>\n                        <button onClick={() => this.visualizeAlgorithm(2)}>\n                            Depth First Search\n                        </button>\n                        <button onClick={() => this.visualizeAlgorithm(3)}>\n                            A*\n                        </button>\n                        <button onClick={() => this.visualizeAlgorithm(4)}>\n                            Greedy Best First Search\n                        </button>\n                        <button onClick={() => this.visualizeAlgorithm(5)}>\n                            BiDirectional BFS\n                        </button>\n                    </div>\n\n                    <div className=\"grid\" id=\"grid\">\n                        {grid.map((row, rowIdx) => {\n                            return (\n                                <div key={rowIdx}>\n                                    {row.map((node, nodeIdx) => {\n                                        const {\n                                            row,\n                                            col,\n                                            isFinish,\n                                            isStart,\n                                            isWall\n                                        } = node;\n                                        return (\n                                            <Node\n                                                key={nodeIdx}\n                                                col={col}\n                                                isFinish={isFinish}\n                                                isStart={isStart}\n                                                isWall={isWall}\n                                                mouseIsPressed={mouseIsPressed}\n                                                onMouseDown={(row, col) =>\n                                                    this.handleMouseDown(\n                                                        row,\n                                                        col\n                                                    )\n                                                }\n                                                onMouseEnter={(row, col) =>\n                                                    this.handleMouseEnter(\n                                                        row,\n                                                        col\n                                                    )\n                                                }\n                                                onMouseUp={() =>\n                                                    this.handleMouseUp()\n                                                }\n                                                row={row}\n                                            ></Node>\n                                        );\n                                    })}\n                                </div>\n                            );\n                        })}\n                    </div>\n                </div>\n            </>\n        );\n    }\n\n    visualizeWalls(maze) {\n        this.clearGrid();\n        if (isRunning) return;\n        isRunning = true;\n        const grid = clearGridHelper();\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n        var turnNodesToWalls = null;\n        switch (maze) {\n            case 0: {\n                turnNodesToWalls = simpleMaze(grid, startNode, finishNode);\n                break;\n            }\n            case 1: {\n                console.log(grid);\n\n                turnNodesToWalls = recursiveDivision(\n                    grid,\n                    1,\n                    NUM_ROWS - 2,\n                    1,\n                    NUM_COLUMNS - 2,\n                    \"HORIZONTAL\",\n                    \"regularMaze\"\n                );\n                console.log(grid);\n                break;\n            }\n            case 2: {\n                turnNodesToWalls = recursiveDivision(\n                    grid,\n                    1,\n                    NUM_ROWS - 2,\n                    1,\n                    NUM_COLUMNS - 2,\n                    \"VERTICAL\",\n                    \"verticalMaze\"\n                );\n                break;\n            }\n            case 3: {\n                turnNodesToWalls = recursiveDivision(\n                    grid,\n                    1,\n                    NUM_ROWS - 2,\n                    1,\n                    NUM_COLUMNS - 2,\n                    \"HORIZONTAL\",\n                    \"horizontalMaze\"\n                );\n                break;\n            }\n            default: {\n                isRunning = false;\n                break;\n            }\n        }\n\n        if (turnNodesToWalls !== null) {\n            this.animateWalls(turnNodesToWalls, grid);\n        }\n    }\n\n    animateWalls(turnNodesToWalls, grid) {\n        for (let i = 0; i <= turnNodesToWalls.length; i++) {\n            setTimeout(() => {\n                const node = turnNodesToWalls[i];\n                if (typeof node !== \"undefined\") {\n                    if (!node.isStart && !node.isFinish && node.isWall) {\n                        document.getElementById(\n                            `node-${node.row}-${node.col}`\n                        ).className = \"node node-wall\";\n                    }\n                }\n\n                if (i === turnNodesToWalls.length - 1) {\n                    isRunning = false;\n                    this.setState({ grid: grid });\n                }\n            }, 10 * i);\n        }\n    }\n\n    clearGrid() {\n        if (isRunning) return;\n        const newgrid = clearGridHelper();\n        this.setState({ grid: newgrid });\n        return newgrid;\n    }\n\n    clearPath(grid) {\n        if (isRunning) return;\n        const newgrid = clearGridHelperKeepWalls(grid);\n        this.setState({ grid: newgrid });\n    }\n\n    refreshPage() {\n        window.location.reload();\n    }\n\n    openHelpMenu() {\n        //make new jsx and css page for the helper menu\n        // make sure background is not interactable when help menu is open\n        // put X button to close\n        // describe algorithms, link github repo site, add tutorial how to use, add inspiraton for the application\n        // Get the modal\n        var modal = document.getElementById(\"helpMenu\");\n        modal.style.display = \"block\";\n\n        // Get the button that opens the modal\n        var btn = document.getElementById(\"info-button\");\n\n        // Get the <span> element that closes the modal\n        var span = document.getElementsByClassName(\"close\")[0];\n\n        console.log(modal, btn, span);\n\n        // When the user clicks on <span> (x), close the modal\n        span.onclick = function() {\n            modal.style.display = \"none\";\n        };\n\n        // When the user clicks anywhere outside of the modal, close it\n        window.onclick = function(event) {\n            if (event.target === modal) {\n                modal.style.display = \"none\";\n            }\n        };\n        this.changeText(1);\n    }\n\n    changeText(next) {\n        const MAXSLIDE = 5;\n        const MINSLIDE = 1;\n\n        if (next === 1) {\n            if (slideNumber === MAXSLIDE) {\n                slideNumber = MAXSLIDE;\n            } else {\n                slideNumber += next;\n            }\n        } else {\n            if (slideNumber === MINSLIDE) {\n                slideNumber = MINSLIDE;\n            } else {\n                slideNumber += next;\n            }\n        }\n        switch (slideNumber) {\n            case 1: {\n                document.getElementById(\"helpMenu-content\").innerHTML =\n                    this.HTMLHelper(MAXSLIDE) +\n                    `<h2 style= \"margin-top: -0.3em;\"> Welcome to the Pathfinding Visualizer!</h2>\n            <p> This pathfinding application involves multiple path finding algorithms from the most famous ones i.e. Dijkstra to a basic search algorithm such as Breadth First Search. \n            Pathfinding algorithms normally compute the shortest path to take from one point to another. It is a fundamental component used in a myriad of applications e.g. Google maps, line following robots and much more. \n            You are also able to generate mazes to test the different algorithms. </p>\n            <p> Click on <strong>Next</strong> to continue the tutorial. Otherwise click anywhere outside the box, or the <strong>X</strong> button to play around with the application.</p>\n            <p><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: 0px;\" src=\"https://i.imgur.com/OkhlgCs.png\" alt=\"\" width=\"245\" height=\"235\" /></p>`;\n                break;\n            }\n\n            case 2: {\n                document.getElementById(\"helpMenu-content\").innerHTML =\n                    this.HTMLHelper(MAXSLIDE) +\n                    `<h2 style= \"margin-top: -0.3em;\">Motivation</h2>\n            <p> My motivation for this project stems from observing the beauty and intricacy of algorithms,  \n             with only the fundamentals of Computer Science, I had to delve deeper to understand much more. As humans we are <strong>lazy</strong>\n             so what better way to learn than to build and create something captivating and visually pleasing to understand more about these algorithms. \n             I hope this application allows you to understand how each algorithm works.</p>\n            <p><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: 50px;\" src=\"https://i.imgur.com/5L2AhLI.png\" alt=\"\" width=\"129\" height=\"129\" /></p>`;\n                break;\n            }\n\n            case 3: {\n                document.getElementById(\"helpMenu-content\").innerHTML =\n                    this.HTMLHelper(MAXSLIDE) +\n                    `<h2 style= \"margin-top: -0.3em;\"> Where to Start? </h2>\n            <p style = \"line-height: 1.15em;\"> Simply left-click your mouse and hover anywhere on the grid to generate walls. \n                To auto-generate mazes you have a few selections of which type of mazes you'd like.Proceed to click any of the algorithms \n                afterwards then magically observe the characteristics of each pathfinding algorithm. You can drag the start and\n                finish node to any place you desire on the grid. You can clear the grid or clear the path of each algorithm after observing. </p>\n                \n            <table style=\"height: 108px; width: 190; margin-left: auto; margin-right: auto;\">\n            <tbody>\n            <tr style=\"height: 33.8px;\">\n            <td style=\"width: 65px; height: 33.8px; text-align: center;\"><img src=\"https://i.imgur.com/IHB0b8r.png\" alt=\"\" width=\"32\" height=\"35\" /></td>\n            <td style=\"width: 116px; height: 30px; text-align: left;\">= Start Node</td>\n            </tr>\n            <tr style=\"height: 17px;\">\n            <td style=\"width: 65px; height: 17px; text-align: center;\"><img src=\"https://i.pinimg.com/originals/ba/3f/f2/ba3ff2209d0c43655116b31f8e2bbd65.png\" alt=\"\" width=\"35\" height=\"40\" /></td>\n            <td style=\"width: 116px; height: 17px; text-align: left;\">= Finish Node</td>\n            </tr>\n            </tbody>\n            </table>\n            <p>&nbsp;</p>\n            `;\n                break;\n            }\n\n            case 4: {\n                document.getElementById(\"helpMenu-content\").innerHTML =\n                    this.HTMLHelper(MAXSLIDE) +\n                    `<h2 style= \"margin-top: -0.3em;\"> Algorithm Information </h2>\n              <table>\n              <tbody>\n              <tr>\n              <td><img src=\"https://i.imgur.com/fnhxgNj.jpg\" alt=\"\" width=\"59\" height=\"60\" /></td>\n              <td>\n              <p style=\"text-align: left; padding-left: 10px\">Click on this icon beside any pathfinding algorithm to view details about&nbsp;\n                how to use the algorithm and detailed commented code about how the algorithm works.\n                Feel free to go to my Github repository on the next page to see how they are implemented.</p>\n              </td>\n              </tr>\n              </tbody>\n              </table>\n            `;\n                break;\n            }\n\n            case 5: {\n                document.getElementById(\"helpMenu-content\").innerHTML =\n                    this.HTMLHelper(MAXSLIDE) +\n                    `<h2 style= \"margin-top: -0.3em;\">Before You Start</h2>\n              <p> I hope you'll have fun fiddling with this application, for further questions or feedback, please do not hesitate to contact me.\n              The code can be found on my Github repository at <a href = \"https://github.com/JamaicanFriedChicken/path-finding-visualizer\" target=\"_blank\">path-finding-visualizer</a> </p>          \n              <p><strong>Note: if your screen is small and the proportions of the maze seem wrong, use CTRL – to zoom out</strong></p>  \n              <table style=\"height: 227px; margin-left: auto; margin-right: auto; width: 552px;\">\n              <tbody>\n              <tr>\n              <td style=\"width: 199px;\"><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: auto;\" src=\"https://i.imgur.com/DdzVMbd.png\" alt=\"\" width=\"152\" height=\"152\" /></td>\n              </tr>\n              </tbody>\n              </table>\n            `;\n                break;\n            }\n\n            default:\n                break;\n        }\n\n        var prevBtn = document.getElementById(\"Prev\");\n        var nextBtn = document.getElementById(\"Next\");\n        if (slideNumber === MINSLIDE) {\n            prevBtn.style.backgroundColor = \"lightgrey\";\n            prevBtn.disabled = true;\n        } else if (slideNumber === MAXSLIDE) {\n            nextBtn.disabled = true;\n            nextBtn.style.backgroundColor = \"lightgrey\";\n        } else {\n            console.log(\"reached here\");\n            prevBtn.disabled = false;\n            prevBtn.style.backgroundColor = \"hsl(214, 100%, 70%)\";\n            nextBtn.disabled = false;\n            nextBtn.style.backgroundColor = \"hsl(214, 100%, 70%)\";\n        }\n    }\n\n    HTMLHelper(MAXSLIDE) {\n        return (\n            `<p> ` +\n            slideNumber +\n            `/` +\n            MAXSLIDE +\n            `<p>\n      `\n        );\n    }\n\n    openAlgorithmMenu(info) {\n        var modal = document.getElementById(\"algo-modal\");\n        modal.style.display = \"block\";\n\n        var modalContent = document.getElementById(\"algo-modal-content\");\n        modalContent.scrollTop = 0;\n\n        // // Get the button that opens the modal\n        // var btn = document.getElementById(\"info-button\");\n\n        // Get the <span> element that closes the modal\n        var span = document.getElementsByClassName(\"algo-close\")[0];\n\n        //console.log(modal, btn, span);\n\n        // When the user clicks on <span> (x), close the modal\n        span.onclick = function() {\n            modal.style.display = \"none\";\n        };\n\n        // When the user clicks anywhere outside of the modal, close it\n        window.onclick = function(event) {\n            if (event.target === modal) {\n                modal.style.display = \"none\";\n            }\n        };\n        document.getElementById(\n            \"algo-modal-content\"\n        ).innerHTML = displayAlgorithmInfo(info);\n    }\n}\n\nfunction getInitialGrid() {\n    const grid = [];\n    for (let row = 0; row < NUM_ROWS; row++) {\n        const currentRow = [];\n        for (let col = 0; col < NUM_COLUMNS; col++) {\n            currentRow.push(createNode(col, row));\n        }\n        grid.push(currentRow);\n    }\n    return grid;\n}\n\nfunction createNode(col, row) {\n    return {\n        col,\n        row,\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n        distance: Infinity,\n        isVisited: false,\n        isWall: false,\n        previousNode: null\n    };\n}\n\nfunction getNewGridWithWallToggled(grid, row, col) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n        ...node,\n        isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n}\n\nfunction clearGridHelper() {\n    const grid = [];\n    for (let row = 0; row < NUM_ROWS; row++) {\n        const currentRow = [];\n\n        for (let col = 0; col < NUM_COLUMNS; col++) {\n            var node = createNode(col, row);\n            node.isWall = false;\n\n            if (!node.isFinish && !node.isStart) {\n                document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className = \"node\";\n            } else if (node.isFinish) {\n                document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className = \"node node-finish\";\n            } else if (node.isStart) {\n                document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className = \"node node-start\";\n            }\n\n            currentRow.push(node);\n        }\n        grid.push(currentRow);\n    }\n    return grid;\n}\n\nfunction clearGridHelperKeepWalls(oldGrid) {\n    const grid = [];\n    for (let row = 0; row < NUM_ROWS; row++) {\n        const currentRow = [];\n\n        for (let col = 0; col < NUM_COLUMNS; col++) {\n            var node = createNode(col, row);\n\n            if (oldGrid[row][col].isWall) node.isWall = true;\n\n            if (node.isWall) {\n                document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className = \"node node-wall\";\n            } else if (!node.isFinish && !node.isStart) {\n                document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className = \"node\";\n            } else if (node.isFinish) {\n                document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className = \"node node-finish\";\n            } else if (node.isStart) {\n                document.getElementById(\n                    `node-${node.row}-${node.col}`\n                ).className = \"node node-start\";\n            }\n\n            currentRow.push(node);\n        }\n        grid.push(currentRow);\n    }\n    return grid;\n}\n","export function displayAlgorithmInfo(info) {\n    switch (info) {\n        case 0: {\n            return `<p style=\"text-align: center;\"><strong>Dijkstra's Algorithm</strong></p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">How it works</span>:</p>\n        <p style=\"text-align: left; padding-left: 30px;\">Dijkstra's algorithm guarantees the shortest path. It is a greedy algorithm that explores unvisited nodes that have the smallest distance from the starting node. The distance/edge weight from one neighbouring node to another is 1. A limitation of Dijkstra's algorithm is that the edge weights have to have a non-negative value.&nbsp;</p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">Implementation</span>:</p>\n        <p style=\"text-align: left;\"><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: -83px\" src=\"https://i.imgur.com/ILm2p0V.png\" alt=\"\" width=\"1370\" height=\"1417\" /></p>\n        `;\n        }\n\n        case 1: {\n            return `<p style=\"text-align: center;\"><strong>Breadth-First Search Algorithm</strong></p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">How it works</span>:</p>\n        <p style=\"text-align: left; padding-left: 30px;\">The Breadth-First Search algorithm guarantees the shortest path. It explores all nodes by layers, or in other words, exploring all the neighbouring nodes at a certain level before moving to the next-level neighbour nodes.&nbsp;</p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">Implementation</span>:&nbsp;<br /><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: -85px\" src=\"https://i.imgur.com/ZkmUeoU.png\" alt=\"\" width=\"1070\" height=\"1190\" /></p>\n        `;\n        }\n\n        case 2: {\n            return `<p style=\"text-align: center;\"><strong>Depth-First Search Algorithm</strong></p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">How it works</span>:</p>\n        <p style=\"text-align: left; padding-left: 30px;\">The Depth-First Search algorithm does not guarantee the shortest path. Depth-First search traverses a maze as deep as far as possible and then comes back to a node to repeat the whole process of going as deep as possible again.&nbsp;</p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">Implementation</span>:&nbsp;</p>\n        <p style=\"text-align: left;\"><br /><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: -137px\" src=\"https://i.imgur.com/eGSub6I.png\" alt=\"\" width=\"1090\" height=\"1250\" /></p>\n        `;\n        }\n        case 3: {\n            return `<p style=\"text-align: center;\"><strong>A* Algorithm</strong></p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">How it works</span>:</p>\n        <p line-height = \"1.2em\" style=\"text-align: left; padding-left: 30px;\">The A* algorithm guarantees the shortest path. The algorithm is similar to Dijkstra's algorithm and Breadth-First Search, but A* differs by using heuristics to essentially plan ahead at each step so a more optimal decision is made. The algorithm uses a function f(n) = g(n) + h(n), where f(n) is the total estimated cost of the path through node n, which we will be using to compare and order nodes in the priority queue. g(n) is the exact cost from the start node to n. h(n) is the heuristic part, it is the estimated cost from n to the finish node. Calculating h(n) can be done using Manhattan, Euclidean, or Diagonal distance. We will be using the Manhattan distance. One neat fact about A* is that if h(n) = 0, A* becomes Dijkstra's algorithms.&nbsp;&nbsp;</p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">Implementation</span>:&nbsp;</p>\n        <p style=\"text-align: left;\"><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: -97px\" src=\"https://i.imgur.com/J1xk90R.png\" alt=\"\" width=\"1200\" height=\"1470\" /><br /><br /></p>\n        `;\n        }\n        case 4: {\n            return `<p style=\"text-align: center;\"><strong>Greedy Best-First Search Algorithm</strong></p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">How it works</span>:</p>\n        <p style=\"text-align: left; padding-left: 30px;\">Greedy Best-First Search Algorithm does not guarantee the shortest path. It is similar to A*, but the only difference is that f(n) = h(n), so the algorithm evaluates nodes by using only the heuristic function as a guide towards the finish node.&nbsp;</p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">Implementation</span>:&nbsp;</p>\n        <p style=\"text-align: left;\"><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: -95px\" src=\"https://i.imgur.com/H2k10Nc.png\" alt=\"\" width=\"1080\" height=\"1624\" /><br /><br /></p>\n        `;\n        }\n        case 5: {\n            return `<p style=\"text-align: center;\"><strong>Bidirectional Breadth-First Search Algorithm</strong></p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">How it works</span>:</p>\n        <p style=\"text-align: left; padding-left: 30px;\">Bidirectional Breadth-First Search Algorithm guarantees the shortest path. It performs Breadth-First Search on both the start and finish nodes and terminates when the two searches intersect with one another.&nbsp;</p>\n        <p style=\"text-align: left;\"><span style=\"text-decoration: underline;\">Implementation</span>:&nbsp;</p>\n        <p style=\"text-align: left;\"><img style=\"display: block; margin-left: auto; margin-right: auto; margin-top: -90px\" src=\"https://i.imgur.com/buofADW.png\" width=\"1080\" height=\"1700\" /><br /><br /></p>`;\n        }\n        default: {\n            return `<p>Sorry, an unexpected error occured, please refresh</p>`;\n        }\n    }\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <PathfindingVisualizer></PathfindingVisualizer>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}